package mining;

import data.Attribute;
import data.ContinuousAttribute;
import data.Data;
import data.DiscreteAttribute;
import java.util.LinkedList;
/**
 * <p>Title: AssociationRuleMiner</p>
 * <p>Description: Association rule miner.</p>
 * <p>Copyright: Copyright (c) 2017</p>
 * <p>Company: Dipartimento di Informatica, Università degli studi di Bari</p>
 * <p>Class description: This class is used to mine association rules linked to a frequent pattern.</p>
 * @author Pier
 * @version 1.0
 */
public class AssociationRuleMiner {
	/**
	 * This method is used to find confident association rules linked to a frequent pattern.
	 * @param data Representation of the database table used for mine operations.
	 * @param fp Frequent pattern used to find its association rules.
	 * @param minConf Minimum confidence of the rule.
	 * @return List of association rules linked to frequent pattern whose confidence is equal or greater than "minConf".
	 * @throws OneLevelPatternException Throws OneLevelPatternException in case a frequent pattern has length of 1.
	 */
	public static LinkedList<AssociationRule> confidentAssociationRuleDiscovery(Data data,FrequentPattern fp,float minConf) throws OneLevelPatternException{
		AssociationRule AR;
		LinkedList<AssociationRule> outputAR=new LinkedList<AssociationRule>();
		if(fp.getPatternLength()==1) throw new OneLevelPatternException("Lenght of "+fp.toString()+" is 1");
		for(int i=1;i<fp.getPatternLength();i++){
			AR=confidentAssociationRuleDiscovery(data,fp,minConf,i);
			if(AR.getConfidence()>=minConf){
				outputAR.add(AR);
			}
		}
		return outputAR;
	}
	/**
	 * This method is used to generate the association rule itself.
	 * @param data Representation of the database table used for mine operations.
	 * @param fp Frequent pattern used to find its association rules.
	 * @param minConf Minimum confidence of the rule.
	 * @param iCut Index used to split the frequent pattern in two parts, antecedent and consequent.
	 * @return New association rule generated by splitting the frequent pattern at "iCut" index.
	 */
	private static AssociationRule confidentAssociationRuleDiscovery(Data data,FrequentPattern fp,float minConf, int iCut){
		AssociationRule AR=new AssociationRule(fp.getSupport());
		
		for(int j=0;j<iCut;j++){
			AR.addAntecedentItem(fp.getItem(j));		
		}

		for(int j=iCut;j<fp.getPatternLength();j++){
			AR.addConsequentItem(fp.getItem(j));
		}	
		AR.setConfidence(AssociationRuleMiner.computeConfidence(data,AR));
		return AR;
	}
	/**
	 * This method is used to calculate association rule's confidence.
	 * @param data Representation of the database table used for mine operations.
	 * @param AR Association rule used to calculate its confidence.
	 * @return Confidence of the rule.
	 */
	private static float computeConfidence(Data data, AssociationRule AR){
		FrequentPattern fullFP=new FrequentPattern();
		FrequentPattern antecedentFP=new FrequentPattern();
		for(int i=0;i<AR.getAntecedentLength();i++){
			fullFP.addItem(AR.getAntecedentItem(i));
			antecedentFP.addItem(AR.getAntecedentItem(i));
		}
		for(int j=0;j<AR.getConsequentLength();j++){
			fullFP.addItem(AR.getConsequentItem(j));
		}
		int fullPatternTransactionNumber=computePatternTransactionNumber(data,fullFP);
		int antecedentPatternTransactionNumber=computePatternTransactionNumber(data,antecedentFP);
		
		return (float) fullPatternTransactionNumber/antecedentPatternTransactionNumber;
	}
	/**
	 * This method is used to calculate the number of supporting pattern transactions.
	 * @param data Representation of the database table used for mine operations.
	 * @param FP Frequent pattern used to calculate its number of supporting pattern transactions.
	 * @return Number of supporting pattern transactions.
	 */
	private static int computePatternTransactionNumber(Data data, FrequentPattern FP){
		int patternTransactionNumber=0;
		for(int i=0;i<data.getNumberOfExamples();i++){
			boolean isSupporting=true;
			for(int j=0;j<FP.getPatternLength();j++){
				Item item;
				Attribute attribute;
				if(FP.getItem(j) instanceof DiscreteItem){
					item=(DiscreteItem) FP.getItem(j);
					attribute=(DiscreteAttribute) item.getAttribute();
				}else{
					item=(ContinuousItem) FP.getItem(j);
					attribute=(ContinuousAttribute) item.getAttribute();
				}
				Object valueInExample=data.getAttributeValue(i,attribute.getIndex());
				if(!item.checkItemCondition(valueInExample)){
					isSupporting=false;
					break;
				}
			}
			if(isSupporting)
				patternTransactionNumber++;
		}
		return patternTransactionNumber;
	}

}